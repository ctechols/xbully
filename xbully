#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'
require 'pp'
require 'wmctrl'
require 'xlib-objects'

class Screen
	def initialize(w, h)
		@width = w;
		@height = h;
	end
	
	def width()
		return @width;
	end

	def height()
		return @height;
	end
end

class Monitor
	def initialize(x, y, w, h)
		@x = x;
		@y = y;
		@width = w;
		@height = h;
	end

	def x()
		return @x;
	end
	
	def y()
		return @y;
	end

	def width()
		return @width;
	end

	def height()
		return @height;
	end

	def top()
		@y
	end

	def bottom()
		@y + @height;
	end

	def left()
		@x;
	end

	def right()
		@x + @width;
	end

	# returns true if the line along the given 'x'
	# intersects the monitor's work area.
	def contains_x?(x)
		(self.left..self.right).include?(x);
	end

	def contains_y?(y)
		(self.top..self.bottom).include?(y)
	end

end

class Window
	def initialize(display, data)
		@display = display
		@data = data;
		@wm = WMCtrl.instance;
	end

	def pp
		Kernel::pp @data
	end

	def title
		@data[:title]
	end

	def active?
		@data[:active]
	end

	def position
		@data.position
	end

	def left
		@data.position[:x]
	end

	def right
		@data.position[:x] + @data.position[:width];
	end

	def top
		@data.position[:y]
	end

	def bottom
		@data.position[:y] + @data.position[:height]
	end

	def width
		@data.position[:width]
	end

	def height
		@data.position[:height]
	end

	def place(opts)
		place_xlib(opts)
	end

	def place_xlib(opts)
		new_position = @data.position.merge(opts);
		# This is going to need to read the existing size hints, set the size 
		# hints to my preference, then restore the original size hints.
		# Use:
		# XGetWMSizeHints
		# XAllocSizeHints.
		# XSetWMSizeHints.
		# Help here: 
		# https://tronche.com/gui/x/xlib/ICC/client-to-window-manager/wm-normal-hints.html
		old_position = @data[:geometry]
		w = XlibObj::Window.new(@display, @data[:id])
		new_position[:width] -= (@data[:frame_extents][0] + @data[:frame_extents][1]);
		new_position[:height] -= (@data[:frame_extents][2] + @data[:frame_extents][3]);
		w.move_resize(new_position[:x], new_position[:y], new_position[:width], new_position[:height]);
		@data = WMCtrl.instance.windows(:id => @data[:id])[0]
		old_position != @data[:geometry]
	end

	def place_wmctrl(opts)
		target_position = @data.position.merge(opts);
		current_position = @data[:geometry]
		## ruby.wmctrl seems to have an issue where it
		## misapplies frame_extent when moving/resizing w window.  Work around 
		## that here.
		target_position[:x] -= @data[:frame_extents][0]
		target_position[:y] -= @data[:frame_extents][1]
		@data.place(target_position)
		new_position = @data[:geometry]
		current_position != new_position
	end

	# returns true if this window is to the right 'w'
	# That is, if this window were moved left solely along the X
	# axis, would its left edge collide with w's
	# left edge? 
	def right_of?(w)
		(w.left < self.left) &&
		(w.top <= self.bottom) &&
		(self.top <= w.bottom)
	end

	def left_of?(w)
		(self.left < w.left) &&
		(w.top <= self.bottom) &&
		(self.top <= w.bottom)
	end

	def below?(w)
		(w.top < self.top) &&
		(w.left <= self.right) &&
		(self.left <= w.right)
	end

	def above?(w)
		(self.top < w.top) &&
		(w.left <= self.right) &&
		(self.left <= w.right)
	end

	# returns true if 'window' and this one overlap.
	def overlap?(window)
		((window.left <= self.right) && (self.left <= window.right)) &&
		((window.top <= self.bottom) && (self.top <= window.bottom))
	end
end

class Desktop
	def Desktop.build()
		display = XlibObj::Display.new(ENV['DISPLAY']);
		screen = get_screen_info(display);
		monitors = get_monitors(display)
		windows = get_visible_windows(display);
		return Desktop.new(display, screen, monitors, windows);
	end

	def Desktop.get_screen_info(display)
		screen_width = display.screens[0].width
		screen_height = display.screens[0].height
		Screen.new(screen_width, screen_height)
	end

	def Desktop.get_monitors(display)
		main_screen = display.screens.first
		monitors = []
		main_screen.crtcs.each { |crtc|
			monitors.push Monitor.new(crtc.x, crtc.y, crtc.width, crtc.height);
		}
		monitors
	end

	def Desktop.get_active_desktop()
		return WMCtrl.instance.list_desktops().select { |d|
			d[:current] == true
		}[0]
	end

	# Gets visible windows on current desktop.
	def Desktop.get_visible_windows(display)
		desktop = get_active_desktop();
		windowData = WMCtrl.instance.windows().select() { |w| 
			(([-1, desktop[:id]].include?(w[:desktop])) ||
			 (w[:state].include?("_NET_WM_STATE_STICKY") )
			) &&
			(!w[:state].include?("_NET_WM_STATE_HIDDEN") ) &&
			(!w[:class].match(/^desktop_window/))
		}
		windowData.map{ |w| Window.new(display, w) }
	end

	def initialize(display, screen, monitors, visible_windows)
		@display = display
		@screen = screen;
		@monitors = monitors;
		@visible_windows = visible_windows;
	end

	def active_window
		@visible_windows.find { |w| w.active? }
	end

	private def next_edge_right(window)
		candidate_edges = @visible_windows.select { |w| 
			w.right_of?(window) && 
			(!w.overlap?(window))
	   	}.collect { |w| w.left }

		candidate_edges.concat @monitors.select { |m|
			m.contains_x?(window.right + 1)
		}.collect { |m| m.right }

		candidate_edges.min() || window.right;
	end

	def pack_right(window)
		new_right = next_edge_right(window);
		window.place(:x => new_right - window.width);
	end

	def grow_right(window)
		new_right = next_edge_right(window);
		window.place(:width => new_right - window.left);
	end

	private def next_edge_left(window)
		candidates_edges = @visible_windows.select {  |w|
			w.left_of?(window) &&
			(!w.overlap?(window))
		}.collect { |w| w.right}

		candidates_edges.concat @monitors.select { |m|
			m.contains_x?(window.left - 1)
		}.collect { |m| m.left }

		candidates_edges.max || window.left
	end

	def pack_left(window)
		new_left = next_edge_left(window);
		window.place(:x => new_left);
	end

	private def next_edge_up(window)
		candidates_edges = @visible_windows.select { |w|
			w.above?(window) &&
			(!w.overlap?(window))
		}.collect { |w| w.bottom }

		candidates_edges.concat @monitors.select { |m|
			m.contains_y?(window.top - 1)
		}.collect { |m| m.top }

		candidates_edges.max || window.top
	end

	def pack_up(window)
		new_top = next_edge_up(window)
		window.place( :y => new_top )
	end

	private def next_edge_down(window)
		candidates_edges = @visible_windows.select { |w|
			w.below?(window) &&
			(!w.overlap?(window))
		}.collect { |w| w.top }

		candidates_edges.concat @monitors.select { |m|
			m.contains_y?(window.bottom + 1)
		}.collect { |m| m.bottom }

		candidates_edges.min || window.bottom
	end

	def pack_down(window)
		new_bottom = next_edge_down(window)
		window.place( :y => new_bottom - window.height)
	end

	private_class_method :get_screen_info, :get_active_desktop, :get_visible_windows
	attr_reader :screen, :monitors, :visible_windows
end

class CommandInterpreter
	def initialize(desktop)
		@desktop = desktop;
	end

	def pack_right(args)
		@desktop.pack_right(@desktop.active_window);
	end

	def grow_right(args)
		@desktop.grow_right(@desktop.active_window);
	end

	def pack_left(args)
		@desktop.pack_left(@desktop.active_window);
	end

	def pack_up(args)
		@desktop.pack_up(@desktop.active_window);
	end

	def pack_down(args)
		@desktop.pack_down(@desktop.active_window)
	end


	def run_command(args)
		@args = args
		cmd = args[0]
		public_send(cmd.to_sym, args);
	end
end

desktop = Desktop.build();
interpreter = CommandInterpreter.new(Desktop.build());
interpreter.run_command(ARGF.argv);
